{
  "description": "Real sample outputs from Claude with and without enhancement",
  "generated": "2025-12-23",
  "tasks": [
    {
      "id": "validate-email",
      "task": "Create a function to validate email addresses",
      "without": "Here's a function to validate email addresses:\n\n```javascript\nfunction validateEmail(email) {\n  // Basic email validation using regex\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return regex.test(email);\n}\n\n// Example usage\nconsole.log(validateEmail('test@example.com')); // true\nconsole.log(validateEmail('invalid')); // false\n```\n\nThis function uses a simple regex pattern to validate the basic email format. You might want to add more robust validation for production use.",
      "with": "I'll follow TDD and implement this step by step.\n\n## Step 1: Write Tests First\n\n```javascript\n// validateEmail.test.js\ndescribe('validateEmail', () => {\n  test('returns true for valid email', () => {\n    expect(validateEmail('user@example.com')).toBe(true);\n  });\n\n  test('returns false for email without @', () => {\n    expect(validateEmail('userexample.com')).toBe(false);\n  });\n\n  test('returns false for email without domain', () => {\n    expect(validateEmail('user@')).toBe(false);\n  });\n\n  test('returns false for empty string', () => {\n    expect(validateEmail('')).toBe(false);\n  });\n\n  test('returns false for null/undefined', () => {\n    expect(validateEmail(null)).toBe(false);\n    expect(validateEmail(undefined)).toBe(false);\n  });\n});\n```\n\n## Step 2: Implement to Pass Tests\n\n```javascript\n/**\n * Validates an email address format.\n * \n * @param {string} email - The email address to validate\n * @returns {boolean} True if valid email format, false otherwise\n * @example\n * validateEmail('user@example.com') // returns true\n * validateEmail('invalid') // returns false\n */\nfunction validateEmail(email) {\n  // Handle null/undefined - do NOT throw, return false\n  if (!email || typeof email !== 'string') {\n    return false;\n  }\n\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return regex.test(email);\n}\n\nmodule.exports = { validateEmail };\n```\n\nConstraints followed:\n- Do NOT throw errors for invalid input\n- Do NOT use overly complex regex\n- Keep function single-purpose (validation only)"
    },
    {
      "id": "fetch-users",
      "task": "Create a function to fetch users from an API",
      "without": "Here's how to fetch users from an API:\n\n```javascript\nasync function fetchUsers() {\n  try {\n    const response = await fetch('https://api.example.com/users');\n    if (!response.ok) {\n      throw new Error('Failed to fetch users');\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    throw error;\n  }\n}\n```\n\nThis handles basic error cases. You can call it like:\n```javascript\nconst users = await fetchUsers();\n```",
      "with": "I'll implement this following TDD principles.\n\n## Step 1: Write Tests First\n\n```javascript\n// fetchUsers.test.js\ndescribe('fetchUsers', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn();\n  });\n\n  test('returns users on successful fetch', async () => {\n    const mockUsers = [{ id: 1, name: 'John' }];\n    fetch.mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve(mockUsers)\n    });\n\n    const result = await fetchUsers();\n    expect(result).toEqual(mockUsers);\n  });\n\n  test('throws error on network failure', async () => {\n    fetch.mockRejectedValueOnce(new Error('Network error'));\n    \n    await expect(fetchUsers()).rejects.toThrow('Failed to fetch users');\n  });\n\n  test('throws error on non-ok response', async () => {\n    fetch.mockResolvedValueOnce({ ok: false, status: 500 });\n    \n    await expect(fetchUsers()).rejects.toThrow('API error: 500');\n  });\n});\n```\n\n## Step 2: Implement to Pass Tests\n\n```javascript\n/**\n * Fetches users from the API.\n * \n * @param {string} [baseUrl] - Optional base URL override\n * @returns {Promise<Array>} Array of user objects\n * @throws {Error} If network request fails or API returns error\n * @example\n * const users = await fetchUsers();\n */\nasync function fetchUsers(baseUrl = 'https://api.example.com') {\n  try {\n    const response = await fetch(`${baseUrl}/users`);\n    \n    if (!response.ok) {\n      throw new Error(`API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    if (error.message.startsWith('API error')) {\n      throw error;\n    }\n    throw new Error('Failed to fetch users: ' + error.message);\n  }\n}\n\nmodule.exports = { fetchUsers };\n```\n\nConstraints:\n- Do NOT swallow errors silently\n- Do NOT hardcode URL (allow injection)\n- Handle both network and API errors"
    },
    {
      "id": "calculate-total",
      "task": "Create a function to calculate shopping cart total with tax",
      "without": "Here's the function:\n\n```typescript\ninterface CartItem {\n  price: number;\n  quantity: number;\n}\n\nfunction calculateTotal(items: CartItem[], taxRate: number): number {\n  const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  const tax = subtotal * taxRate;\n  return Math.round((subtotal + tax) * 100) / 100; // Round to 2 decimal places\n}\n\n// Example\nconst total = calculateTotal([{price: 10, quantity: 2}], 0.08);\nconsole.log(total); // 21.6\n```\n\nThis calculates the subtotal, applies tax, and rounds to avoid floating point issues.",
      "with": "## Step 1: Define Types and Write Tests\n\n```typescript\n// types.ts\ninterface CartItem {\n  price: number;\n  quantity: number;\n}\n\ninterface CartTotal {\n  subtotal: number;\n  tax: number;\n  total: number;\n}\n```\n\n```typescript\n// calculateTotal.test.ts\ndescribe('calculateTotal', () => {\n  test('calculates correct total with tax', () => {\n    const items = [{ price: 10, quantity: 2 }];\n    const result = calculateTotal(items, 0.1);\n    expect(result.subtotal).toBe(20);\n    expect(result.tax).toBe(2);\n    expect(result.total).toBe(22);\n  });\n\n  test('returns zero for empty cart', () => {\n    const result = calculateTotal([], 0.1);\n    expect(result.total).toBe(0);\n  });\n\n  test('throws for negative prices', () => {\n    expect(() => calculateTotal([{ price: -10, quantity: 1 }], 0.1))\n      .toThrow('Invalid price');\n  });\n\n  test('throws for invalid tax rate', () => {\n    expect(() => calculateTotal([], -0.1)).toThrow('Invalid tax rate');\n  });\n});\n```\n\n## Step 2: Implement\n\n```typescript\n/**\n * Calculates shopping cart total including tax.\n * \n * @param items - Array of cart items with price and quantity\n * @param taxRate - Tax rate as decimal (e.g., 0.08 for 8%)\n * @returns Object with subtotal, tax amount, and total\n * @throws {Error} If prices are negative or tax rate is invalid\n * \n * @example\n * const result = calculateTotal([{price: 10, quantity: 2}], 0.08);\n * // { subtotal: 20, tax: 1.6, total: 21.6 }\n */\nfunction calculateTotal(items: CartItem[], taxRate: number): CartTotal {\n  // Validate tax rate - do NOT accept negative rates\n  if (taxRate < 0 || taxRate > 1) {\n    throw new Error('Invalid tax rate: must be between 0 and 1');\n  }\n\n  // Validate items\n  for (const item of items) {\n    if (item.price < 0) throw new Error('Invalid price: cannot be negative');\n    if (item.quantity < 0) throw new Error('Invalid quantity');\n  }\n\n  const subtotal = items.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n\n  const tax = subtotal * taxRate;\n\n  return {\n    subtotal: Math.round(subtotal * 100) / 100,\n    tax: Math.round(tax * 100) / 100,\n    total: Math.round((subtotal + tax) * 100) / 100\n  };\n}\n```\n\nSOLID: Single responsibility - only calculates totals, validation is separate concern but kept minimal."
    },
    {
      "id": "format-date",
      "task": "Create a utility function to format dates",
      "without": "Here's a date formatting utility:\n\n```javascript\nfunction formatDate(date, options = {}) {\n  const { locale = 'en-US', format = 'long' } = options;\n  \n  const formatOptions = format === 'short' \n    ? { year: 'numeric', month: '2-digit', day: '2-digit' }\n    : { year: 'numeric', month: 'long', day: 'numeric' };\n\n  return new Date(date).toLocaleDateString(locale, formatOptions);\n}\n\n// Examples\nformatDate(new Date()); // \"December 23, 2025\"\nformatDate('2025-12-23', { format: 'short' }); // \"12/23/2025\"\n```\n\nYou can pass a Date object or a date string, and optionally specify the format.",
      "with": "## Step 1: Tests First\n\n```javascript\n// formatDate.test.js\ndescribe('formatDate', () => {\n  test('formats date in default format', () => {\n    const date = new Date('2025-12-23');\n    expect(formatDate(date)).toBe('December 23, 2025');\n  });\n\n  test('accepts string date input', () => {\n    expect(formatDate('2025-12-23')).toBe('December 23, 2025');\n  });\n\n  test('returns \"Invalid Date\" for invalid input', () => {\n    expect(formatDate('not-a-date')).toBe('Invalid Date');\n    expect(formatDate(null)).toBe('Invalid Date');\n  });\n\n  test('supports custom format option', () => {\n    const date = new Date('2025-12-23');\n    expect(formatDate(date, { format: 'short' })).toBe('12/23/2025');\n  });\n});\n```\n\n## Step 2: Implementation\n\n```javascript\n/**\n * Formats a date into a human-readable string.\n * \n * @param {Date|string|number} input - Date to format\n * @param {Object} [options] - Formatting options\n * @param {string} [options.format='long'] - 'long', 'short', or 'iso'\n * @param {string} [options.locale='en-US'] - Locale for formatting\n * @returns {string} Formatted date string or 'Invalid Date'\n * \n * @example\n * formatDate(new Date()) // \"December 23, 2025\"\n * formatDate('2025-12-23', { format: 'short' }) // \"12/23/2025\"\n */\nfunction formatDate(input, options = {}) {\n  const { format = 'long', locale = 'en-US' } = options;\n\n  // Handle null/undefined - do NOT throw\n  if (input == null) {\n    return 'Invalid Date';\n  }\n\n  const date = input instanceof Date ? input : new Date(input);\n\n  // Check for invalid date\n  if (isNaN(date.getTime())) {\n    return 'Invalid Date';\n  }\n\n  const formats = {\n    long: { year: 'numeric', month: 'long', day: 'numeric' },\n    short: { year: 'numeric', month: '2-digit', day: '2-digit' },\n    iso: null // Special case\n  };\n\n  if (format === 'iso') {\n    return date.toISOString().split('T')[0];\n  }\n\n  return date.toLocaleDateString(locale, formats[format] || formats.long);\n}\n\nmodule.exports = { formatDate };\n```\n\nOpen/Closed: Easy to add new formats without modifying existing code."
    },
    {
      "id": "user-class",
      "task": "Create a User class with validation",
      "without": "Here's a User class with validation:\n\n```typescript\nclass User {\n  private name: string;\n  private email: string;\n\n  constructor(name: string, email: string) {\n    if (!name || name.trim().length === 0) {\n      throw new Error('Name is required');\n    }\n    if (!email || !email.includes('@')) {\n      throw new Error('Valid email is required');\n    }\n    this.name = name.trim();\n    this.email = email.toLowerCase();\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getEmail(): string {\n    return this.email;\n  }\n\n  updateEmail(newEmail: string): void {\n    if (!newEmail || !newEmail.includes('@')) {\n      throw new Error('Valid email is required');\n    }\n    this.email = newEmail.toLowerCase();\n  }\n}\n```\n\nThe class validates inputs in the constructor and provides getters and an update method.",
      "with": "## Step 1: Define Interface and Tests\n\n```typescript\n// User.test.ts\ndescribe('User', () => {\n  describe('constructor', () => {\n    test('creates user with valid data', () => {\n      const user = new User({ name: 'John', email: 'john@example.com' });\n      expect(user.name).toBe('John');\n      expect(user.email).toBe('john@example.com');\n    });\n\n    test('throws for empty name', () => {\n      expect(() => new User({ name: '', email: 'a@b.com' }))\n        .toThrow('Name is required');\n    });\n\n    test('throws for invalid email', () => {\n      expect(() => new User({ name: 'John', email: 'invalid' }))\n        .toThrow('Invalid email');\n    });\n  });\n\n  describe('updateEmail', () => {\n    test('updates email when valid', () => {\n      const user = new User({ name: 'John', email: 'old@example.com' });\n      user.updateEmail('new@example.com');\n      expect(user.email).toBe('new@example.com');\n    });\n  });\n});\n```\n\n## Step 2: Implementation\n\n```typescript\n/**\n * Represents a user in the system.\n * \n * @example\n * const user = new User({ name: 'John', email: 'john@example.com' });\n */\nclass User {\n  private _name: string;\n  private _email: string;\n  private readonly _createdAt: Date;\n\n  /**\n   * Creates a new User instance.\n   * @param data - User data object\n   * @throws {Error} If name is empty or email is invalid\n   */\n  constructor(data: { name: string; email: string }) {\n    // Validate - do NOT accept empty values\n    if (!data.name || data.name.trim().length === 0) {\n      throw new Error('Name is required');\n    }\n\n    if (!this.isValidEmail(data.email)) {\n      throw new Error('Invalid email format');\n    }\n\n    this._name = data.name.trim();\n    this._email = data.email.toLowerCase();\n    this._createdAt = new Date();\n  }\n\n  /** User's display name */\n  get name(): string {\n    return this._name;\n  }\n\n  /** User's email address */\n  get email(): string {\n    return this._email;\n  }\n\n  /** When user was created */\n  get createdAt(): Date {\n    return this._createdAt;\n  }\n\n  /**\n   * Updates user's email address.\n   * @param newEmail - New email to set\n   * @throws {Error} If email is invalid\n   */\n  updateEmail(newEmail: string): void {\n    if (!this.isValidEmail(newEmail)) {\n      throw new Error('Invalid email format');\n    }\n    this._email = newEmail.toLowerCase();\n  }\n\n  /**\n   * Validates email format.\n   * @param email - Email to validate\n   * @returns True if valid format\n   */\n  private isValidEmail(email: string): boolean {\n    if (!email) return false;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n  }\n}\n\nexport { User };\n```\n\nSOLID Principles Applied:\n- Single Responsibility: User only manages user data\n- Open/Closed: Can extend via inheritance without modifying\n- Encapsulation: Private fields with getters"
    }
  ]
}
