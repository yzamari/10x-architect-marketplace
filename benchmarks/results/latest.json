{
  "timestamp": "2025-12-23T06:34:23.599Z",
  "summary": {
    "avgOriginal": "1.3",
    "avgEnhanced": "98.8",
    "improvement": "97.5"
  },
  "results": [
    {
      "id": "feature-simple",
      "original": "add a search bar to the header",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 6,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will add a search bar component to the application header.\n\nNORTH STAR\nEnable users to quickly find content, improving navigation efficiency and user satisfaction.\n\nCONSTRAINTS\n- Do NOT implement backend search functionality yet (frontend only)\n- Do NOT modify existing header layout significantly\n- Do NOT add external search library dependencies\n- Must not break existing header responsiveness\n\nEXECUTION PHASES\n1. Write unit tests for SearchBar component (input handling, state management)\n2. Create SearchBar component with controlled input\n3. Write integration tests for Header with SearchBar\n4. Integrate SearchBar into Header component\n5. Add styling consistent with existing design system\n6. Document the SearchBar component API and usage\n\nTDD REQUIREMENTS\n- Write failing test first (RED)\n- Implement minimum code to pass (GREEN)\n- Refactor while keeping tests green (REFACTOR)\n- Test edge cases: empty input, special characters, max length\n- Test accessibility: keyboard navigation, screen reader support\n\nDOCUMENTATION REQUIREMENTS\n- Add JSDoc comments to SearchBar component and all methods\n- Update README with SearchBar usage examples\n- Document props interface and event handlers\n- Add inline comments for complex logic\n\nSOLID PRINCIPLES\n- Single Responsibility: SearchBar only handles search UI, not search logic\n- Open/Closed: Extensible for future search providers via props\n- Dependency Inversion: Inject onSearch callback, don't hardcode behavior\n- Interface Segregation: Minimal props interface (value, onChange, onSearch)\n\nQUALITY GUARDRAILS\nThink step-by-step through each phase.\nCritique your implementation for:\n- Accessibility (ARIA labels, keyboard support)\n- Performance (debounce input events)\n- Mobile responsiveness\n- Error handling for edge cases"
    },
    {
      "id": "feature-medium",
      "original": "implement user authentication",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 11,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will implement a secure user authentication system with login, logout, and session management.\n\nNORTH STAR\nEnable users to securely access their accounts while maintaining excellent user experience and protecting sensitive data.\n\nCONSTRAINTS\n- Do NOT implement password reset in initial scope\n- Do NOT store plain text passwords\n- Do NOT use deprecated crypto methods\n- Do NOT modify existing user database schema significantly\n- Must not expose sensitive tokens in URLs or logs\n\nEXECUTION PHASES\n1. Write tests for password hashing utilities\n2. Implement password hashing with bcrypt\n3. Write tests for JWT token generation/validation\n4. Implement JWT token service\n5. Write tests for authentication middleware\n6. Create authentication middleware\n7. Write tests for login/logout endpoints\n8. Implement login and logout API endpoints\n9. Write tests for session management\n10. Add session management and token refresh\n11. Document authentication flow and API\n\nTDD REQUIREMENTS\n- Write failing test first (RED)\n- Implement minimum code to pass (GREEN)\n- Refactor while keeping tests green (REFACTOR)\n- Test edge cases: invalid credentials, expired tokens, concurrent sessions\n- Test security: SQL injection, XSS, CSRF protection\n\nDOCUMENTATION REQUIREMENTS\n- Add JSDoc/docstrings to all auth functions\n- Update README with authentication setup guide\n- Document API endpoints with request/response examples\n- Add security considerations documentation\n\nSOLID PRINCIPLES\n- Single Responsibility: Separate TokenService, AuthService, UserService\n- Open/Closed: Extensible for OAuth providers without modification\n- Liskov Substitution: All auth providers implement IAuthProvider interface\n- Dependency Inversion: Inject database and token dependencies\n- Interface Segregation: Separate interfaces for token, session, user operations\n\nQUALITY GUARDRAILS\nThink step-by-step through each phase.\nCritique your implementation for:\n- Token storage security (HttpOnly cookies vs localStorage)\n- XSS and CSRF protection\n- Rate limiting for login attempts\n- Session invalidation on logout\n- Secure password requirements"
    },
    {
      "id": "feature-complex",
      "original": "add a real-time notification system with websockets",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 6,
        "phase_count": 11,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will implement a real-time notification system using WebSocket connections for instant message delivery.\n\nNORTH STAR\nEnable users to receive instant updates and notifications, improving engagement and keeping them informed without page refreshes.\n\nCONSTRAINTS\n- Do NOT implement push notifications (browser notifications) in initial scope\n- Do NOT store notifications permanently (in-memory for MVP)\n- Do NOT exceed 1000 concurrent connections per server initially\n- Do NOT send sensitive data through WebSocket without encryption\n- Must not break existing REST API functionality\n\nEXECUTION PHASES\n1. Write tests for WebSocket connection manager\n2. Implement WebSocket server setup and connection handling\n3. Write tests for notification event handlers\n4. Create notification event system (subscribe, publish, unsubscribe)\n5. Write tests for client-side WebSocket hook\n6. Implement React hook for WebSocket connections\n7. Write tests for notification UI components\n8. Create notification display components (toast, badge, panel)\n9. Write integration tests for end-to-end flow\n10. Integrate with existing user authentication\n11. Document WebSocket API and client usage\n\nTDD REQUIREMENTS\n- Write failing test first (RED)\n- Implement minimum code to pass (GREEN)\n- Refactor while keeping tests green (REFACTOR)\n- Test edge cases: connection drops, reconnection, message ordering\n- Test performance: multiple concurrent connections, message throughput\n\nDOCUMENTATION REQUIREMENTS\n- Add JSDoc comments to all WebSocket handlers and hooks\n- Update README with WebSocket setup and configuration\n- Document notification event types and payloads\n- Add architecture diagram for real-time flow\n\nSOLID PRINCIPLES\n- Single Responsibility: Separate ConnectionManager, NotificationService, EventEmitter\n- Open/Closed: Extensible for new notification types without modification\n- Liskov Substitution: All transports implement ITransport interface\n- Dependency Inversion: Inject transport layer, don't hardcode WebSocket\n- Interface Segregation: Separate interfaces for connection, messaging, subscription\n\nQUALITY GUARDRAILS\nThink step-by-step through each phase.\nCritique your implementation for:\n- Connection resilience and auto-reconnection\n- Memory leaks from uncleared subscriptions\n- Message ordering and delivery guarantees\n- Authentication for WebSocket connections\n- Graceful degradation when WebSocket unavailable"
    },
    {
      "id": "bugfix-simple",
      "original": "fix the login button not working",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 6,
        "phase_count": 9,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will investigate and fix the login button functionality issue to restore user authentication capability.\n\nNORTH STAR\nEnsure users can successfully log into their accounts, maintaining trust and access to the application.\n\nCONSTRAINTS\n- Do NOT modify authentication logic without understanding root cause\n- Do NOT change unrelated code\n- Do NOT remove existing error handling\n- Must not introduce regression in other auth features\n- Do NOT deploy fix without test verification\n\nEXECUTION PHASES\n1. Write a failing test that reproduces the bug\n2. Investigate: Check browser console for errors\n3. Investigate: Verify event handlers are attached\n4. Investigate: Check network requests and responses\n5. Identify root cause and document findings\n6. Implement minimal fix to pass the failing test\n7. Write additional tests for edge cases discovered\n8. Verify fix doesn't break existing tests\n9. Document the bug and fix in commit message\n\nTDD REQUIREMENTS\n- Write failing test first that reproduces the bug (RED)\n- Implement minimum fix to pass (GREEN)\n- Refactor if needed while keeping tests green (REFACTOR)\n- Test edge cases: double-click, rapid clicks, form validation\n- Verify no regression in existing login tests\n\nDOCUMENTATION REQUIREMENTS\n- Document root cause analysis in PR description\n- Add inline comment explaining the fix if non-obvious\n- Update troubleshooting guide if applicable\n\nSOLID PRINCIPLES\n- Single Responsibility: Fix only the broken functionality\n- Open/Closed: Don't modify working code unnecessarily\n\nQUALITY GUARDRAILS\nThink step-by-step through investigation.\nCritique your fix for:\n- Side effects on other functionality\n- Edge cases that might cause similar issues\n- Performance implications\n- User experience during error states"
    },
    {
      "id": "bugfix-medium",
      "original": "fix the memory leak in the dashboard component",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 9,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will identify and fix the memory leak in the dashboard component to improve application performance and stability.\n\nNORTH STAR\nEnsure the dashboard performs reliably over extended use sessions without degrading browser performance or causing crashes.\n\nCONSTRAINTS\n- Do NOT refactor unrelated dashboard code\n- Do NOT change component architecture without profiling data\n- Do NOT remove functionality to fix the leak\n- Must not introduce new dependencies for the fix\n- Do NOT merge without memory profiling verification\n\nEXECUTION PHASES\n1. Write a test that detects memory growth over iterations\n2. Profile dashboard with browser DevTools Memory tab\n3. Identify retained objects and detached DOM nodes\n4. Trace leak source: event listeners, timers, subscriptions, closures\n5. Document root cause with heap snapshot evidence\n6. Implement fix: proper cleanup in useEffect/componentWillUnmount\n7. Write tests verifying cleanup functions are called\n8. Re-profile to verify memory is released\n9. Document fix and prevention guidelines\n\nTDD REQUIREMENTS\n- Write failing test that shows memory growth (RED)\n- Implement cleanup to pass memory test (GREEN)\n- Refactor cleanup patterns while tests pass (REFACTOR)\n- Test edge cases: rapid mount/unmount, route changes\n- Verify cleanup runs on all unmount scenarios\n\nDOCUMENTATION REQUIREMENTS\n- Document memory profiling methodology used\n- Add JSDoc comments to cleanup functions\n- Update component documentation with lifecycle notes\n- Add memory leak prevention guidelines to contributing guide\n\nSOLID PRINCIPLES\n- Single Responsibility: Each effect handles one subscription/cleanup\n- Dependency Inversion: Use cleanup callbacks, not direct references\n\nQUALITY GUARDRAILS\nThink step-by-step through profiling.\nCritique your fix for:\n- All event listeners properly removed\n- All timers/intervals cleared\n- All subscriptions unsubscribed\n- Closure references released\n- AbortController for fetch requests"
    },
    {
      "id": "refactor-simple",
      "original": "refactor the utils file",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 8,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will refactor the utils file to improve code organization, maintainability, and testability.\n\nNORTH STAR\nCreate a well-organized utility module that is easy to understand, test, and extend for future development needs.\n\nCONSTRAINTS\n- Do NOT change function signatures without updating all call sites\n- Do NOT remove any exported functions without deprecation\n- Do NOT combine unrelated utilities into single files\n- Must not break existing tests\n- Do NOT introduce circular dependencies\n\nEXECUTION PHASES\n1. Write/verify tests for all existing utility functions\n2. Audit current utils: categorize by domain (string, date, array, etc.)\n3. Plan new file structure with related functions grouped\n4. Create new utility modules with proper exports\n5. Move functions one by one, updating imports\n6. Write additional tests for uncovered edge cases\n7. Update barrel exports (index.ts) for backwards compatibility\n8. Document new utility module structure\n\nTDD REQUIREMENTS\n- Ensure all functions have tests before refactoring (RED if missing)\n- Move code only when tests pass (GREEN)\n- Refactor internal implementation while tests stay green (REFACTOR)\n- Test edge cases for each utility function\n- Maintain 100% test coverage through refactoring\n\nDOCUMENTATION REQUIREMENTS\n- Add JSDoc comments to all utility functions\n- Document parameters, return types, and examples\n- Update README with new import paths\n- Add deprecation notices if changing exports\n\nSOLID PRINCIPLES\n- Single Responsibility: One file per utility domain\n- Open/Closed: Add new utils without modifying existing\n- Interface Segregation: Export only what's needed publicly\n- Dependency Inversion: Utilities should be pure functions\n\nQUALITY GUARDRAILS\nThink step-by-step through each move.\nCritique your refactoring for:\n- Breaking changes to public API\n- Import path changes across codebase\n- Bundle size impact\n- Tree-shaking compatibility"
    },
    {
      "id": "refactor-medium",
      "original": "refactor the API module to use async/await",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 9,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will refactor the API module to replace Promise chains with async/await syntax for improved readability and error handling.\n\nNORTH STAR\nImprove developer experience and code maintainability by using modern JavaScript patterns that are easier to read, debug, and extend.\n\nCONSTRAINTS\n- Do NOT change API response formats or behavior\n- Do NOT modify error handling semantics\n- Do NOT convert working code without tests\n- Must not break existing API consumers\n- Do NOT mix Promise chains and async/await in same function\n\nEXECUTION PHASES\n1. Write/verify integration tests for all API endpoints\n2. Audit Promise chains: identify all .then()/.catch() patterns\n3. Convert one endpoint at a time, starting with simplest\n4. Replace .then() chains with await statements\n5. Replace .catch() with try/catch blocks\n6. Handle Promise.all with await Promise.all\n7. Verify tests pass after each conversion\n8. Update error handling to use async patterns\n9. Document async patterns and error handling approach\n\nTDD REQUIREMENTS\n- Verify all endpoints have tests before conversion (RED if missing)\n- Convert only when tests exist and pass (GREEN)\n- Refactor error handling while tests stay green (REFACTOR)\n- Test error scenarios: network failure, timeout, invalid response\n- Test concurrent requests with Promise.all\n\nDOCUMENTATION REQUIREMENTS\n- Add JSDoc with @async annotation to converted functions\n- Document error handling patterns used\n- Update API module README with async/await examples\n- Add inline comments for complex async flows\n\nSOLID PRINCIPLES\n- Single Responsibility: Each API function handles one endpoint\n- Open/Closed: Easy to add new async endpoints\n- Dependency Inversion: Inject fetch/axios instance\n\nQUALITY GUARDRAILS\nThink step-by-step through each conversion.\nCritique your refactoring for:\n- Error propagation consistency\n- Proper await placement\n- Memory leaks from unhandled promises\n- Race condition prevention\n- Cancellation support with AbortController"
    },
    {
      "id": "refactor-complex",
      "original": "refactor the monolithic service into microservices",
      "originalScore": "0.0",
      "enhancedScore": "87.5",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": false,
        "constraint_count": 5,
        "phase_count": 11,
        "score": 7,
        "maxScore": 8,
        "percentage": "87.5"
      },
      "enhanced": "GOAL\nWe will refactor the monolithic service into separate microservices to improve scalability, maintainability, and deployment flexibility.\n\nNORTH STAR\nEnable independent scaling, deployment, and development of system components, reducing coupling and improving team velocity.\n\nCONSTRAINTS\n- Do NOT break existing API contracts during migration\n- Do NOT migrate all services at once (incremental approach)\n- Do NOT share databases between services initially\n- Must not introduce network latency without measurement\n- Do NOT remove monitoring and logging during transition\n\nEXECUTION PHASES\n1. Write integration tests for current monolith API surface\n2. Identify service boundaries using domain analysis\n3. Define API contracts between services (OpenAPI specs)\n4. Create first microservice: extract User domain\n5. Write tests for User service in isolation\n6. Implement User service with its own database\n7. Create API gateway for routing\n8. Write integration tests for gateway routing\n9. Migrate traffic incrementally with feature flags\n10. Repeat for remaining domains: Orders, Products, etc.\n11. Document architecture and deployment procedures\n\nTDD REQUIREMENTS\n- Write contract tests between services (RED if contract violated)\n- Each service must have isolated test suite (GREEN)\n- Refactor internal implementation while contracts hold (REFACTOR)\n- Test service failures: circuit breaker, fallback, retry\n- Test data consistency across service boundaries\n\nDOCUMENTATION REQUIREMENTS\n- Create architecture decision records (ADRs) for each split\n- Document service boundaries and responsibilities\n- Add OpenAPI specifications for each service\n- Update deployment runbooks for each service\n- Document inter-service communication patterns\n\nSOLID PRINCIPLES\n- Single Responsibility: Each service owns one business domain\n- Open/Closed: Services extensible via their APIs\n- Liskov Substitution: Service implementations swappable\n- Interface Segregation: Minimal, focused API contracts\n- Dependency Inversion: Services communicate via abstractions (APIs, events)\n\nQUALITY GUARDRAILS\nThink step-by-step through each extraction.\nCritique your architecture for:\n- Data consistency and eventual consistency patterns\n- Network failure handling\n- Service discovery and load balancing\n- Distributed tracing and logging\n- Rollback strategy for failed migrations"
    },
    {
      "id": "docs-simple",
      "original": "add documentation to the auth module",
      "originalScore": "12.5",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": true,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 1,
        "maxScore": 8,
        "percentage": "12.5"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 9,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will add comprehensive documentation to the auth module including API docs, usage examples, and inline code comments.\n\nNORTH STAR\nEnable developers to quickly understand, integrate, and extend the authentication module without diving deep into implementation details.\n\nCONSTRAINTS\n- Do NOT modify functionality while documenting\n- Do NOT use outdated documentation patterns\n- Do NOT document internal/private functions publicly\n- Must not expose sensitive security details\n- Do NOT create documentation that requires constant updates\n\nEXECUTION PHASES\n1. Write tests for documentation examples (ensure they work)\n2. Audit existing code: identify public API surface\n3. Add JSDoc comments to all public functions\n4. Add JSDoc comments to interfaces and types\n5. Create README with quick start guide\n6. Add code examples for common use cases\n7. Document error codes and handling\n8. Add architecture overview with diagrams\n9. Review and test all documentation examples\n\nTDD REQUIREMENTS\n- Write tests that run documentation examples (RED if examples broken)\n- Ensure example code passes tests (GREEN)\n- Refactor examples while tests pass (REFACTOR)\n- Test edge cases mentioned in documentation\n- Verify documented error scenarios are accurate\n\nDOCUMENTATION REQUIREMENTS\n- JSDoc for all public functions with @param, @returns, @throws, @example\n- TypeScript interface documentation with @description\n- README with installation, configuration, and usage\n- CHANGELOG for version history\n- Security considerations section\n\nSOLID PRINCIPLES\n- Single Responsibility: Each doc file covers one topic\n- Open/Closed: Documentation extensible without rewriting\n- Interface Segregation: Separate docs for different audiences\n\nQUALITY GUARDRAILS\nThink step-by-step through each doc section.\nCritique your documentation for:\n- Accuracy against actual code behavior\n- Completeness of public API coverage\n- Clarity for developers new to the codebase\n- Example code that actually runs\n- Security-sensitive information exposure"
    },
    {
      "id": "test-simple",
      "original": "add tests for the user service",
      "originalScore": "0.0",
      "enhancedScore": "100.0",
      "originalMetrics": {
        "has_goal": false,
        "has_north_star": false,
        "has_constraints": false,
        "has_phases": false,
        "has_tdd": false,
        "has_docs": false,
        "has_solid": false,
        "has_edge_cases": false,
        "constraint_count": 0,
        "phase_count": 0,
        "score": 0,
        "maxScore": 8,
        "percentage": "0.0"
      },
      "enhancedMetrics": {
        "has_goal": true,
        "has_north_star": true,
        "has_constraints": true,
        "has_phases": true,
        "has_tdd": true,
        "has_docs": true,
        "has_solid": true,
        "has_edge_cases": true,
        "constraint_count": 5,
        "phase_count": 10,
        "score": 8,
        "maxScore": 8,
        "percentage": "100.0"
      },
      "enhanced": "GOAL\nWe will add comprehensive test coverage for the user service including unit tests, integration tests, and edge case coverage.\n\nNORTH STAR\nEnsure the user service is reliable, maintainable, and protected against regressions through thorough automated testing.\n\nCONSTRAINTS\n- Do NOT modify user service code during initial test writing\n- Do NOT mock internal implementation details\n- Do NOT write tests that are flaky or environment-dependent\n- Must not expose test utilities as production code\n- Do NOT skip edge cases for faster coverage\n\nEXECUTION PHASES\n1. Audit user service: list all public methods and behaviors\n2. Write unit tests for pure utility functions\n3. Write unit tests for UserService class methods\n4. Write tests for validation logic\n5. Write tests for error handling paths\n6. Write integration tests for database operations\n7. Write integration tests for API endpoints\n8. Write edge case tests: null inputs, boundary values, concurrent operations\n9. Measure and document coverage percentage\n10. Add tests for any uncovered branches\n\nTDD REQUIREMENTS\n- Write failing test for each untested behavior (RED)\n- Verify production code makes test pass (GREEN)\n- Refactor tests for clarity while staying green (REFACTOR)\n- Test edge cases: empty strings, null, undefined, max values\n- Test async edge cases: timeouts, race conditions\n\nDOCUMENTATION REQUIREMENTS\n- Add JSDoc comments describing each test file's purpose\n- Document test data setup and fixtures\n- Add comments explaining non-obvious test assertions\n- Update README with instructions to run tests\n- Document coverage requirements and thresholds\n\nSOLID PRINCIPLES\n- Single Responsibility: Each test file tests one module\n- Open/Closed: Test utilities extensible without modification\n- Dependency Inversion: Inject mocks via dependency injection\n- Interface Segregation: Separate test utilities by purpose\n\nQUALITY GUARDRAILS\nThink step-by-step through each test category.\nCritique your tests for:\n- Test isolation (no shared state)\n- Meaningful assertions (not just \"no error\")\n- Readable test names describing behavior\n- Appropriate use of mocks vs real implementations\n- Coverage of failure paths, not just happy paths"
    }
  ]
}